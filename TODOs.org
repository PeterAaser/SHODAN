* Neste gang
  Hente register fra DSP, sette bitfields og sende tilbake
    
* Database notes
** To open db in terminal:
   peter$~/:    sudo su postgres
   postgres$~/: psql -d world -U postgres

   select name from country;
   \q
** To redo a database
   peter$~/:    sudo su postgres
   postgres$~/: psql -c 'drop database $db;' -U postgres
   postgres$~/: psql -c 'create database $db;' -U postgres
   postgres$~/: psql -c '\i $db.sql' -d $db -U postgres

* About neurons
** Filtering
   None of these assumptions have any sort of neurological basis, they're just assumed
   in order to get a working prototype.

   I assume maximum amount of spikes we're interested in recording is 50 per second


* DONE Fix perf issue with sending data to frontend. It keeps buffering way past shutting down MEAME
  Turns out it was queue segment size being 1
** DONE Try to create a send only program
** DONE Figure out the deal with queue sizes
   dequeueAvailable or dequeueBatch achieves what we're after

* DONE Chunk all data from TCP for easier restarts etc
  As it is, the datastream from MEAME and the DB does not identify which segment is running.
  By adding tags we can make it easier to restart etc.
  Should topics get the same treatment?

* TODO Fix the GA for the last time
** DONE Create generic version
** DONE Test with simple example
** TODO reimplement GA in terms of generic version
** TODO figure out how to dequeueAvailable without losing unconsumed

* TODO Better handling of parameters
** TODO Define requirements
   'better' is not a requirement, although in its current state it's not
   100% wrong either. Ideally params should be a signal or some other IO
   mutable construct, including an isReady IO[Bool]

* TODO Less unescessary restarts for both SHODAN and MEAME
** DONE MEAME
** TODO SHODAN
*** DONE Other item [[*Chunk all data from TCP for easier restarts etc][Chunk Incoming]]
*** TODO UI support
** TODO Reset protocol(?)
   Might not be necessary unless we somehow lose track of an input stream
   In this scenario we can't demodulate the TCP datastream

* TODO Add TCP listening for other users, possibly on specific channels
  With HTTP
* TODO Improve the frontend
** TODO Settings accessible on the frontend
** TODO Make a spec before randomly writing a lot of code
** TODO Redo basic UI
   Added react, now to learn using it. Ish

** TODO Add functionality for making a recording
*** TODO UI elements
*** TODO Backend support

** TODO Functionality for stim protocols?
   Oh fuck me
*** TODO UI elements
*** TODO MEAME support?
*** TODO DSP support

* DONE Add sine wave generator on MEAME for debugging
  Ended up being sawtooth, no difference really

* TODO Add tests

* how 2 fs2 fra gitter (ikke slett plz)
Yeah, I do that in too many places
but soon I've got a working version out, then I'm gonna refactor and write good tests and all that jazz while the stable version automagically outputs research data
and everyone will be happy

Fabio Labella @SystemFw 15:51
then you'd need to write the usual recursive function as you do with Pulls in general
and then recursive(input).stream to get a Pipe

PeterAaser @PeterAaser 15:52
btw, is there a good place to get an idea of how fs2 works on the inside?

Fabio Labella @SystemFw 15:52
yes
the code :stuck_out_tongue:

PeterAaser @PeterAaser 15:52
Say I want to learn enough about to fs2 to actually contribute

Fabio Labella @SystemFw 15:52
sorry

PeterAaser @PeterAaser 15:52
How would you start

Fabio Labella @SystemFw 15:52
so there's a few layers, so to speak

PeterAaser @PeterAaser 15:52
I've actually read much of the code, but I tend to not stray into the core parts where scary things lie

Fabio Labella @SystemFw 15:53
so what I do

PeterAaser @PeterAaser 15:53
like don't ask me what a FreeC is (Free and coyoneda?)

Fabio Labella @SystemFw 15:53
no, that's just a Free monad with an extra constructor to take care of exception handling
cats Free already has coyoneda embedded in it
so I have a few random suggestions
first of all, master the Stream api (apart from where concurrency is involved)
assuming that it works by magic
but like, try and figure out what each method does, how to combine them, useful patterns and the like

PeterAaser @PeterAaser 15:55
I'm pretty good at the stream API. My activity in this channel might give a false impression, but that's because I usually only ask when I need to do something stupid :stuck_out_tongue:

Fabio Labella @SystemFw 15:55
lol I was speaking in general, not your specific knowledge :stuck_out_tongue:

PeterAaser @PeterAaser 15:56
but it's definitely a good place to keep improving

Fabio Labella @SystemFw 15:56
then do the same, but learning about the implementations
which are kinda divided in different categories
i.e. things that are written in terms of other streams combinators <- these are the best
concurrency/cats-effect <- I'll tell you about this in a second
things that are implemented using Pull <- this are the second best

PeterAaser @PeterAaser 15:57
How about stuff like scopes which aren't really visible to the end user?

Fabio Labella @SystemFw 15:57
things that are primitives <- last

PeterAaser @PeterAaser 15:57
unless something that shouldn't explode explodes

Fabio Labella @SystemFw 15:57
well, you just need to figure out the core interpreter for that
so Algebra
it's tricky, not gonna lie

PeterAaser @PeterAaser 15:58
haha I remember some of the signatures from 0.9

Fabio Labella @SystemFw 15:58
a good exercise is to dive into the async package, however
it's kinda standalone

PeterAaser @PeterAaser 15:58
The algebraF thing
that's a good tip

Fabio Labella @SystemFw 15:58
what I did
is spending a weekend going from the Java memory model (which you need to understand the lock-free queue used in actor)
then from actor to the implementation of Ref
than from the semantics of Ref to the concurrent data structures
and then from there to the concurrent combinators join, start concurrently and so on

PeterAaser @PeterAaser 16:00
That's for the async part, right?

Fabio Labella @SystemFw 16:00
yes
there's kinda two styles of concurrency is fs2 (this is my own informal split, so don't take it for granted)

PeterAaser @PeterAaser 16:00
Right, that sounds like a good way to go about it

Fabio Labella @SystemFw 16:00
stuff in async, which I've just mentioned
and stuff like merge, which ultimately relies on AsyncPull
but the async package itself is challenging enough as a start, imho
one extra tip
you don't have to go all the way down
for example, there's no need to understand how Actor works

PeterAaser @PeterAaser 16:01
Yeah, that's a good point

Fabio Labella @SystemFw 16:01
its semantics are very clear, so you can assume them as primitives
because understanding actor can be very tricky
I'm keen on low level concurrency so I did that
but it's not necessary
unless you fancy reading about lock-free algorithms in C

PeterAaser @PeterAaser 16:02
Haha, I'm running the parallel computations coursework at my university
I try very hard to avoid semaphores and similar unless I absolutely have to

Fabio Labella @SystemFw 16:03
You should also bear in mind that I'm a maintainer, and I don't know everything about the library yet

PeterAaser @PeterAaser 16:03
It's just impossible to get them right consistantly

Fabio Labella @SystemFw 16:03
so you could definitely contribute something while you learn
well, the fs2 semaphores are quite nice :P
but yeah, have you ever used haskell STM?

PeterAaser @PeterAaser 16:04
Thanks a lot, I hope I get some free time soon so I can finally go back to dagobah and finish my jedi training
No, learning haskell is on my to-do list
can't be that hard to learn haskell when I write functional scala

Fabio Labella @SystemFw 16:04
:+1:
sweetest concurrency model I've used
actually, you're mostly going to find that a lot of things are easier/less convoluted
although I really like scala as well

PeterAaser @PeterAaser 16:05
I really prefer scalas syntax, it's much easier for me to parse
although I dislike curly braces
and the type inferenc
Like how can Nil not be inferred
aornshdi

Fabio Labella @SystemFw 16:06
ime, syntax really does depend on habit
I used to hate scala syntax and its noise
now I don't mind it at all

PeterAaser @PeterAaser 16:06
(0 /: List[A[Lot[Of[Stuff]]]]())(_+_)

Fabio Labella @SystemFw 16:06
lol

PeterAaser @PeterAaser 16:06
instead of (0 /: Nil)(_+_)
but apart from that I find scalas type declarations to be very informative and I don't mind them at all

Fabio Labella @SystemFw 16:07
foldl' 0 (+)
the kind syntax is atrocious

PeterAaser @PeterAaser 16:08
I quite like /:
oh yes
but bearable with macros luckily
that's why I bet on scala, because shit like that ends up being fixed
and not just with boilerplate tools
lol, friend sent me this
http://i.4cdn.org/sci/1507818316576.png

proof via interpretive dance

Fabio Labella @SystemFw 16:09
amazing

PeterAaser @PeterAaser 16:09
we should totally find out what it is and find a way to incorporate it into the fs2 docs

* React
  < is for tags and tag attributes (<.div and <div looks similar)
  ^ is for attributes since it's concise

  underscore seemingly indicates we don't want to care about renderscope

  render_P: ((String) => VDomElement)                                  => Step4
  renderP:  ((RenderScope[String, Unit, Unit], String) => VDomElement) => Step4

  the renderScope is typically passed as $ (which is a legal identifier in scala, who knew)

  props: basically function argument for a UI component
  state: stuff that changes which a component may or may not react to (?)

* React Code scalajs vs js
#+begin_src js
  class ProductCategoryRow extends React.Component {
    render() {
      return (
        <tr>
          <td style={{fontWeight: 'bold'}}>{this.props.category}</td>
        </tr>
      );
    }
  }
#+end_src

  translates to

#+begin_src scala
  val ProductCategoryRow_ = ScalaComponent.builder[String]("ProductCategoryRow")
    .render_P(category => <.tr(<.th(^.colSpan := 2, category)))
    .build
#+end_src

  The takeaway is that the render_P expects a string from a prop which the js version
  does more explicitly
  Also the scala version is very terse with the < and ^ notation, maybe we can afford
  more linebreaks, keeping in mind that the js version also has to close...

** More
#+begin_src js
class Timer extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      secondsElapsed: 0
    };
    this.tick = this.tick.bind(this);
  }

  tick() {
    this.setState({secondsElapsed: this.state.secondsElapsed + 1});
  }

  componentDidMount() {
    this.interval = setInterval(this.tick, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.interval);
  }

  render() {
    return React.createElement("div", null, "Seconds Elapsed: ", this.state.secondsElapsed);
  }
}

ReactDOM.render(React.createElement(Timer), mountNode);
#+end_src

* Circe
  Figure out how I can work with Map for working with registers info without having to resort to
  the clumsy stuff I'm using now.

* MCS meeting talking points
** MEAME data acquisition
** DSP stim stuff
*** How can I debug this stuff
*** The mcs update tool
*** Blanking etc
*** Generating stimulus patterns
*** Uploading stimulus patterns from the computer
*** Code samples plz

** Blanking
   Only for the equipment

* Register representation
  case 1: Bit field with only one member
  case 2: Bit fields with many members (for instance 30 bits representing 15 2bit fields)

  case 2 can be handled with a list of case 1. Should it?
  How about a method for generating these?


