* Neste gang
  Sjekk at recording og playback fungerer som det skal.

* Doing
  Id is being set to 1 for all datarecordings, likely hardcoded somewhere
  Drop DB and start a new one to have something to test with only one record.
  
  Does play back database file records properly, but breaks because it still
  tries to communicate with MEAME2 on stim requests.
  
  insertExperiment in doobio returns 1. Is this the amount of inserted records 
  rather than the new ID? (probably)
  withUniqueGeneratedKeys??

* Now
** TODO Add tests
   Maybe read the chapter on prop testing in the red book?
*** DONE Get hello world test to run
    sort of, the frontend kinda stopped working... hurr!
*** TODO Make simple sine wave playback server/harness
*** TODO Make database playback mock server/harness
   
** TODO Stimulus
*** TODO Rewrite stimulus.
**** DONE Write
    See MEAMEutilz
**** TODO Verify
** TODO Verify and finish file playback.
*** DONE Add basic user interface support
*** TODO Figure out how to start and stop recordings
    Start should be params -> IO[IO[Unit]] perhaps?
    Outer IO is the start, the inner IO is the finalization which
    writes metadata to the db etc?
*** TODO Verify that recording triangle waves from MEAME2 works
**** TODO Stream to database
     Had an issue where using a queue would cause displaying and
     saving data caused the data to get split, rather than duplicated.
     
     Now uses topic, which should fix the problem
     
**** TODO Stream from database
*** TODO Specify how I want files parsed and delegate slave labor
*** TODO Get throttling to work properly
*** TODO Verify correctness
   
** TODO Redo build file
   Look at build.sbt.next
   When testing out the new build file make sure scala js
   actually updates.
* Later
** TODO Spec out and properly implement DB
*** TODO add more todo items
** TODO Refactor Feedback pipe
   not critical
*** TODO figure out how to dequeueAvailable without losing unconsumed
*** TODO The filter should not be responsible for termination
**** TODO Can we change evaluator to a Pipe[F, O, Option[Double]]
     Might deadlock or whatever
    
** TODO Better handling of parameters
*** TODO Define requirements
    'better' is not a requirement, although in its current state it's not
    100% wrong either. Possibly params could be a signal or some other IO
    mutable construct, including an isReady IO[Bool].
    Sort of react-ish way of handling it

** TODO Less unescessary restarts for both SHODAN and MEAME
*** DONE MEAME
*** TODO SHODAN
**** DONE Other item [[*Chunk all data from TCP for easier restarts etc][Chunk Incoming]]
**** TODO UI support
*** TODO Reset protocol(?)
    Might not be necessary unless we somehow lose track of an input stream
    In this scenario we can't demodulate the TCP datastream
    Have actually managed to trigger this error, so it might be an issue

** TODO Add TCP listening for other users, possibly on specific channels
   With HTTP
** TODO Improve the frontend
*** TODO Get rid of the annyoing redundant clicks!!
*** TODO Settings accessible on the frontend
*** TODO Make a spec before randomly writing a lot of code
*** TODO Redo basic UI
   Added react, now to learn using it. Ish

*** TODO Add functionality for making a recording
**** TODO UI elements
**** TODO Backend support

*** TODO Functionality for stim protocols?
**** TODO UI elements
**** TODO MEAME support?
**** TODO DSP support
    See refactoring representation element

** TODO Refactor registry representation
*** DONE Refine register representation.
*** DONE Check correctness of STG.scala
*** TODO Make specialized rendering per field basis
   For instance electrode enable should use ✘ and ✓ instead of dumping everything
   Similarily, this allows for more sensible per group rendering.
   Currently it's worth asking if this is actually needed, can we simply get by
   with a specialized function? (yes)
*** TODO Create specialized stimulus upload
   Let this be handled on the DSP for now...
*** TODO Refactor HttpClient stuff, get the forest under control.
   
* Finished
** DONE Write more documentation
** DONE Stim req system
*** DONE Implement
*** DONE Test
**** DONE Implement logging rig
**** DONE Debug with logging rig
** DONE Implement stim on MEAME
** DONE Fix perf issue with sending data to frontend. It keeps buffering way past shutting down MEAME
  Turns out it was queue segment size being 1
*** DONE Try to create a send only program
*** DONE Figure out the deal with queue sizes
   dequeueAvailable or dequeueBatch achieves what we're after

** DONE Chunk all data from TCP for easier restarts etc
   As it is, the datastream from MEAME and the DB does not identify which segment is running.
   By adding tags we can make it easier to restart etc.
   Should topics get the same treatment?
** DONE Fix the GA for the last time
*** DONE Create generic version
*** DONE Test with simple example
*** DONE reimplement GA in terms of generic version
**** DONE Implement
**** DONE Make it work
  
** DONE Add sine wave generator on MEAME for debugging
  Ended up being sawtooth, no difference really



* how 2 fs2 fra gitter (ikke slett plz)
Yeah, I do that in too many places
but soon I've got a working version out, then I'm gonna refactor and write good tests and all that jazz while the stable version automagically outputs research data
and everyone will be happy

Fabio Labella @SystemFw 15:51
then you'd need to write the usual recursive function as you do with Pulls in general
and then recursive(input).stream to get a Pipe

PeterAaser @PeterAaser 15:52
btw, is there a good place to get an idea of how fs2 works on the inside?

Fabio Labella @SystemFw 15:52
yes
the code :stuck_out_tongue:

PeterAaser @PeterAaser 15:52
Say I want to learn enough about to fs2 to actually contribute

Fabio Labella @SystemFw 15:52
sorry

PeterAaser @PeterAaser 15:52
How would you start

Fabio Labella @SystemFw 15:52
so there's a few layers, so to speak

PeterAaser @PeterAaser 15:52
I've actually read much of the code, but I tend to not stray into the core parts where scary things lie

Fabio Labella @SystemFw 15:53
so what I do

PeterAaser @PeterAaser 15:53
like don't ask me what a FreeC is (Free and coyoneda?)

Fabio Labella @SystemFw 15:53
no, that's just a Free monad with an extra constructor to take care of exception handling
cats Free already has coyoneda embedded in it
so I have a few random suggestions
first of all, master the Stream api (apart from where concurrency is involved)
assuming that it works by magic
but like, try and figure out what each method does, how to combine them, useful patterns and the like

PeterAaser @PeterAaser 15:55
I'm pretty good at the stream API. My activity in this channel might give a false impression, but that's because I usually only ask when I need to do something stupid :stuck_out_tongue:

Fabio Labella @SystemFw 15:55
lol I was speaking in general, not your specific knowledge :stuck_out_tongue:

PeterAaser @PeterAaser 15:56
but it's definitely a good place to keep improving

Fabio Labella @SystemFw 15:56
then do the same, but learning about the implementations
which are kinda divided in different categories
i.e. things that are written in terms of other streams combinators <- these are the best
concurrency/cats-effect <- I'll tell you about this in a second
things that are implemented using Pull <- this are the second best

PeterAaser @PeterAaser 15:57
How about stuff like scopes which aren't really visible to the end user?

Fabio Labella @SystemFw 15:57
things that are primitives <- last

PeterAaser @PeterAaser 15:57
unless something that shouldn't explode explodes

Fabio Labella @SystemFw 15:57
well, you just need to figure out the core interpreter for that
so Algebra
it's tricky, not gonna lie

PeterAaser @PeterAaser 15:58
haha I remember some of the signatures from 0.9

Fabio Labella @SystemFw 15:58
a good exercise is to dive into the async package, however
it's kinda standalone

PeterAaser @PeterAaser 15:58
The algebraF thing
that's a good tip

Fabio Labella @SystemFw 15:58
what I did
is spending a weekend going from the Java memory model (which you need to understand the lock-free queue used in actor)
then from actor to the implementation of Ref
than from the semantics of Ref to the concurrent data structures
and then from there to the concurrent combinators join, start concurrently and so on

PeterAaser @PeterAaser 16:00
That's for the async part, right?

Fabio Labella @SystemFw 16:00
yes
there's kinda two styles of concurrency is fs2 (this is my own informal split, so don't take it for granted)

PeterAaser @PeterAaser 16:00
Right, that sounds like a good way to go about it

Fabio Labella @SystemFw 16:00
stuff in async, which I've just mentioned
and stuff like merge, which ultimately relies on AsyncPull
but the async package itself is challenging enough as a start, imho
one extra tip
you don't have to go all the way down
for example, there's no need to understand how Actor works

PeterAaser @PeterAaser 16:01
Yeah, that's a good point

Fabio Labella @SystemFw 16:01
its semantics are very clear, so you can assume them as primitives
because understanding actor can be very tricky
I'm keen on low level concurrency so I did that
but it's not necessary
unless you fancy reading about lock-free algorithms in C

PeterAaser @PeterAaser 16:02
Haha, I'm running the parallel computations coursework at my university
I try very hard to avoid semaphores and similar unless I absolutely have to

Fabio Labella @SystemFw 16:03
You should also bear in mind that I'm a maintainer, and I don't know everything about the library yet

PeterAaser @PeterAaser 16:03
It's just impossible to get them right consistantly

Fabio Labella @SystemFw 16:03
so you could definitely contribute something while you learn
well, the fs2 semaphores are quite nice :P
but yeah, have you ever used haskell STM?

PeterAaser @PeterAaser 16:04
Thanks a lot, I hope I get some free time soon so I can finally go back to dagobah and finish my jedi training
No, learning haskell is on my to-do list
can't be that hard to learn haskell when I write functional scala

Fabio Labella @SystemFw 16:04
:+1:
sweetest concurrency model I've used
actually, you're mostly going to find that a lot of things are easier/less convoluted
although I really like scala as well

PeterAaser @PeterAaser 16:05
I really prefer scalas syntax, it's much easier for me to parse
although I dislike curly braces
and the type inferenc
Like how can Nil not be inferred
aornshdi

Fabio Labella @SystemFw 16:06
ime, syntax really does depend on habit
I used to hate scala syntax and its noise
now I don't mind it at all

PeterAaser @PeterAaser 16:06
(0 /: List[A[Lot[Of[Stuff]]]]())(_+_)

Fabio Labella @SystemFw 16:06
lol

PeterAaser @PeterAaser 16:06
instead of (0 /: Nil)(_+_)
but apart from that I find scalas type declarations to be very informative and I don't mind them at all

Fabio Labella @SystemFw 16:07
foldl' 0 (+)
the kind syntax is atrocious

PeterAaser @PeterAaser 16:08
I quite like /:
oh yes
but bearable with macros luckily
that's why I bet on scala, because shit like that ends up being fixed
and not just with boilerplate tools
lol, friend sent me this
http://i.4cdn.org/sci/1507818316576.png

proof via interpretive dance

Fabio Labella @SystemFw 16:09
amazing

PeterAaser @PeterAaser 16:09
we should totally find out what it is and find a way to incorporate it into the fs2 docs

* React
  < is for tags and tag attributes (<.div and <div looks similar)
  ^ is for attributes since it's concise

  underscore seemingly indicates we don't want to care about renderscope

  render_P: ((String) => VDomElement)                                  => Step4
  renderP:  ((RenderScope[String, Unit, Unit], String) => VDomElement) => Step4

  the renderScope is typically passed as $ (which is a legal identifier in scala, who knew)

  props: basically function argument for a UI component
  state: stuff that changes which a component may or may not react to (?)

* React Code scalajs vs js
#+begin_src js
  class ProductCategoryRow extends React.Component {
    render() {
      return (
        <tr>
          <td style={{fontWeight: 'bold'}}>{this.props.category}</td>
        </tr>
      );
    }
  }
#+end_src

  translates to

#+begin_src scala
  val ProductCategoryRow_ = ScalaComponent.builder[String]("ProductCategoryRow")
    .render_P(category => <.tr(<.th(^.colSpan := 2, category)))
    .build
#+end_src

  The takeaway is that the render_P expects a string from a prop which the js version
  does more explicitly
  Also the scala version is very terse with the < and ^ notation, maybe we can afford
  more linebreaks, keeping in mind that the js version also has to close...

** More
#+begin_src js
class Timer extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      secondsElapsed: 0
    };
    this.tick = this.tick.bind(this);
  }

  tick() {
    this.setState({secondsElapsed: this.state.secondsElapsed + 1});
  }

  componentDidMount() {
    this.interval = setInterval(this.tick, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.interval);
  }

  render() {
    return React.createElement("div", null, "Seconds Elapsed: ", this.state.secondsElapsed);
  }
}

ReactDOM.render(React.createElement(Timer), mountNode);
#+end_src

* Circe
  Figure out how I can work with Map for working with registers info without having to resort to
  the clumsy stuff I'm using now.

* On registers and DSPs
  Problem: A device can be controlled by setting bits, however this is a very
  primitive encoding, offering no semantic description.
  
  A register may contain several fields, and some registers may even have
  different semantics for some bits based on other bits.
  
  I want a system that feels more ergonomic to program, but also allows us
  to catch impossible configurations at compile time, which means we prefer
  registers to not be stringly typed. We may even go as far as having codecs
  specific for some memory regions which allows us to decode a register that
  can have multiple meanings. This might make compile time detection of errors
  harder, but we can possibly use decoders only and simply dump the register 
  if it's invalid.
  
  There are several possible identifiers for a register:
  + name
    A register should have a semantic name. Should address -> name be surjective?
    injective?

  + address
    Should all addresses be covered?

  + group membership?

  What we're really trying to describe is the relations address, field, name
  and package it somewhat reasonably
  
  We want to be able to query fields, set fields, we shouldn't have to care
  about addresses at all other than when visualizing.
  Do we want custom visualizers?
  
** Syntax?
   Problem: We want a map of possible 
   
* Database notes
** To open db in terminal:
   peter$~/:    sudo su postgres
   postgres$~/: psql -d world -U postgres

   select name from country;
   \q
** To redo a database
   peter$~/:    sudo su postgres
   postgres$~/: psql -c 'drop database $db;' -U postgres
   postgres$~/: psql -c 'create database $db;' -U postgres
   postgres$~/: psql -c '\i $db.sql' -d $db -U postgres
   
** Some commands
   \dt to show tables

** Doobie pitfalls
   For the doobie sql string interpolator $ is not simply textual replacement!
   This means that 
   #+begin_src scala
     val aa = "aa"
     val zip = "ZIP"
     sql"""
       INSERT INTO dataRecording (experimentId, resourcePath, resourceType)
       VALUES (123, $aa, $zip)
     """.update.check.unsafeRunSync()
    #+end_src

   is not equal to
   
   #+begin_src scala
    sql"""
      INSERT INTO dataRecording (experimentId, resourcePath, resourceType)
      VALUES (123, aa, zip)
    """.update.check.unsafeRunSync()
   #+end_src

   However this does not hold for numbers!
   
   

* About neurons
** Filtering
   None of these assumptions have any sort of neurological basis, they're just assumed
   in order to get a working prototype.

   I assume maximum amount of spikes we're interested in recording is 50 per second


* Issues with output from MEAME
  It seems the data corruption issues only happen with low samplerates.
  At 10000hz the ground is correctly rendered. WHY?
  Gunnar suggests DSP using only one of its two memory bands. Not too far fetched
* Dev diary
** GA terminates after one evaluation
   Turns out the filter terminated after TicksPerEval,
   however we need 5*ticksPerEval for 5 challenges!
   This is a hint that the current method isn't very
   ergonomical, it should not be the responsibility of
   the filter to know when it's done.

  [[file:backend/src/main/scala/cyborg/streamAssemblers.scala::def%20startSHODAN(implicit%20ec:%20ExecutionContext):%20Stream%5BIO,%20Unit%5D%20=%20{][start shodan in stream assemblers]] 
   
* Clogged stream checklist
  + NYI exceptions might end up being swallowed
  + Check if all streams are running, not just the head of a stream of streams etc.
** Previous cases
     
*** The mystery of the silent topics
   I suspect this issue has been a problem for a long time, but I finally found it when
   working on porting the GA to the new generalized framework.
   This gave me a very large surface of errors, I'm not sure it was a good idea, or if I
   would have been better off using the old GA stuff, which at least worked.
   After unsuccessfully looking at the GA and generalized pipe code I decided to test if
   data was even getting through which I did by printing the head of the list of streams from
   topic in Assemblers. This only worked because I happened to choose the first topic, which
   it turns out had all the data. I then tried to rewrite roundrobin yet again (poor round
   robin was likely framed many times because of this silly bug). When I couldn't get that 
   to work, I tried to simply interleave the two first streams, which also clogged! I then
   attempted to run output only from the second stream, which gave no output! This made me 
   realize that in all likelyhood the broadcaster had a bug, which it indirectly did. The
   broadcaster simply multiplexes tagged segments based on their channel tag, tags which was
   added in the tag pipe. The tag pipe was the source of the bug in the end, as it didn't 
   actually increment the tag inbetween segments! OOPS!!!
   Fix: 
   
   >>>>>>
   Pull.output1(TaggedSegment(n, seg.toVector)) >> go(n%60, tl)
   <<<<<<
   Pull.output1(TaggedSegment(n, seg.toVector)) >> go((n + 1) % 60, tl)
          
*** Return of the unimplemented method
    Implemented a new pipe for producing stimulus signal periods. The function from Hz to 
    period was not implemented but the exception was swallowed.
    This should be tested properly, but until then using ??? is very dangerous since NYI 
    errors might be swallowed.


* On testing
  Scala has 3 major testing frameworks.
  + ScalaCheck
    Focuses on property-based testing 
  + specs2
    Concentrates on behavior-drive development. 
  + ScalaTest 
    a flexible testing platform.
    "ScalaTest enables teams to use the style of testing that fits them best, and
    supports property-based testing via integration with ScalaCheck."
  
  These frameworks are compatible with each other, typically
  ScalaTest and ScalaCheck are used in conjunction.
