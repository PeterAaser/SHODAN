* TODO Add error handling
** TODO On TCP connection close do some cool shit
 
* DONE Persistent storage
  CLOSED: [2017-04-27 to. 12:08]
** DONE Write MEAME input to file
   CLOSED: [2017-03-13 ma. 17:47]
*** DONE Write raw input to file
    CLOSED: [2017-03-12 sø. 12:40]
*** DONE Write parameters to file
    CLOSED: [2017-03-13 ma. 17:47]
** DONE Read MEAME input from file
   CLOSED: [2017-03-14 ti. 17:07]
*** DONE Read raw input from file
    CLOSED: [2017-03-14 ti. 17:07]
**** DONE write implementation
     CLOSED: [2017-03-12 sø. 16:02]
**** DONE test implementation
     CLOSED: [2017-04-29 lø. 17:22]
*** DONE Read params from file
    CLOSED: [2017-03-13 ma. 17:47]
**** DONE write implementation
     CLOSED: [2017-03-12 sø. 16:03]
**** DONE test implementation
     CLOSED: [2017-04-29 lø. 17:22]

    
** DONE Test and fix write and read
   CLOSED: [2017-03-18 lø. 13:03]

** DONE Add a real webscale database
   CLOSED: [2017-04-27 to. 12:08]

* TODO Create main control module
** DONE Rethink Inner/Outer 
   CLOSED: [2017-05-17 on. 17:31]
*** DONE Agnostic IO toplevel
    CLOSED: [2017-05-17 on. 17:31]
*** DONE Refactor the plethora of IO methods into logical units
    CLOSED: [2017-04-30 sø. 19:51]
**** DONE Database IO
     CLOSED: [2017-04-29 lø. 17:21]
***** Why two logical units? 
      In order to get a clean interface between doobie and the rest of the codebase
      the database part is defined in separate files.
      One immediate reason for doing so is to help ensime not choke on preprocessor
      stuff (cats/scalaz) in doobie.
***** DONE Doobie tasks
      CLOSED: [2017-04-29 lø. 17:21]
****** DONE Remove every reference to doobieTasks outside of database tasks
       CLOSED: [2017-04-29 lø. 17:21]
***** DONE Database tasks
      CLOSED: [2017-04-29 lø. 17:21]
**** DONE File IO 
     CLOSED: [2017-04-29 lø. 17:21]
**** DONE TCP IO
     CLOSED: [2017-04-29 lø. 17:22]
    
** TODO Outer loop
*** DONE Should dispatch the inner loop
    CLOSED: [2017-05-10 on. 13:49]
**** TODO MEAME needs an API for selecting datastream
**** TODO should create the bulk logging task and inner loop task with MEAME sockets
*** DONE Should be responsible for opening the server connections to MEAME
    CLOSED: [2017-03-11 lø. 17:01]
*** DONE Outer loop should log all incoming data from MEAME
    CLOSED: [2017-04-27 to. 12:10]
**** DONE Create flat fileWriter
     CLOSED: [2017-03-11 lø. 17:01]
**** TODO Write to database
** TODO Inner loop
*** TODO Inner loop should be responsible for trying out different ANNs
**** TODO Implement rudimentary evaluator
**** TODO Implement sophisticated evaluator
     Thinking of using scalapagos here

*** DONE Refactor inner loop
    CLOSED: [2017-03-11 lø. 17:01]
    Inner loop must be refactored to offer a pipeline where stages are more suited for working
    in parallel without duplicating work
*** TODO Add pipe rebuilding to some criteria
**** DONE Create proof of concept
     CLOSED: [2017-05-15 ma. 17:11]
     See scala-playground
**** TODO Generalize proof of concept and add to SHODAN
** Spec
   Control module should:
*** Should open connection to server
*** Should modify the pipe by replacing it with a new version
*** Modification should be done by listening to various feedback from the current pipe

* TODO Create RPC pipes
** Notes
   When a new MEAMEControl is instantiated the constructor should return a stream.
   This stream will be connected to all available input actions, pat match it from there.

* TODO Better DI
** TODO Figure out best practice for DI
*** TODO Try out Free monad
** TODO SHODAN should be able to select experiment params from either file of conf.
*** Create parses for params

* TODO Make website prettier
** Notes
   Needs to be webscale

* General maintenance
** DONE Fix alternator
   CLOSED: [2017-04-29 lø. 17:23]
   Doesn't look right, and even if it is it's much too arcane so a rewrite can't hurt


* Notes
** TODO Logging
   In order to log what SHODAN does and thinks it could be useful to implement a logging scheme.
   This is possibly something best done with Task (or F[_].. ), check it out.

* Sist gang
  Har nå: 
** experimentPipe: Pipe[Double, ANNpipe] med intern state (gitt at vi er i sync...)
** evalPipe: Pipe[Agent,Double] som står for å lage challenges (fem stykk) og kjøre agents gjennom
  

* Doobie notes

  #+BEGIN_SRC scala
  def niceMeme(meme: Int): Int = meme + meme
  #+END_SRC

* Database specification
** ER
   For each experiment
*** Metadata
   Experiment parameters
   Date (start, finish)
   Culture name
   Textual description

*** Experiment data
   Raw data chunks?

   On experiment start: if data recording: create an experimentInfo field and a set of channelRecordings.
   Each channelRecording should get its own sink for storing data.
** Use cases
*** Query for all recordings in some timespan
*** Query for all recordings with length over 4 minutes
*** Reading the experiment the runner decides to retry from some timestamp with a different filter
*** A program reads both raw data and a processed stream (spike data)
*** A program processes spike detection for all recordings in some range of time

* Database notes
** To open db in terminal:
   peter$~/:    sudo su postgres 
   postgres$~/: psql -d world -U postgres
  
   select name from country;
   \q
** To redo a database
   peter$~/:    sudo su postgres 
   postgres$~/: psql -c 'drop database $db;' -U postgres
   postgres$~/: psql -c 'create database $db;' -U postgres
   postgres$~/: psql -c '\i $db.sql' -d $db -U postgres
   

* fs2 Notes
  for eksempel på pull der R representerer Handle, se takeWhile i Handle
** DONE Pipe of pipes
   CLOSED: [2017-05-15 ma. 17:02]
   Bruker queue som basically lar oss gjøre mer i flatmap som en slags side-effect
   Se scala-playground, it's all done :D
