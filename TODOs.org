* Thought scratchpad
  Currently I'm not separating network data broadcasting and interfacing with MEAME.
  MEAME control (stop and start MEAME) should only perform HTTP calls, then let the 
  appropriate broadcast actions be run.
  Thus there should be two actions, broadcast from network (which may or may not have 
  data) and broadcast from DB (which may also not have data if not initialized)
  
  Is it really so wrong to not always broadcast when MEAME is running though? Maybe for testing?
  
  Been thinking more about the broadcaster. What if I make the broadcaster sort of a top level thing 
  and instead of respawning the broadcaster I let the broadcaster handle that for itself so that 
  it will be easier to monitor.
  Perhaps this is prudent for more parts of the codebase, ensure that each component is a persistent 
  container for its internal streams which may be interrupted and restarted.

* Neste gang
  Figure out what is going on with agent causing everything to blow up
  Line 60 in assemblers
  
  Looks like the problem might be in AssembleGA
  
* Doing
  Remove primitive DSP requests

* Now 
** TODO Redo DSP requests  
   Currently all auxillary DSP functionality from MEAME is disabled.
*** TODO DSP barf log
*** TODO Consider re-adding auxillary methods (reset and upload)
*** TODO Stimulus call
** TODO MCS csv parser
** TODO Verify stimuli
   After this all work necessary for actually performing experiments will be completed.
*** Implement stim group on backend
*** Create test cases
*** Verify stimuli upload
** TODO Add logging for agent state for playback   
** TODO Fix MCS channel duplication bug
* Later
** TODO Standardize names in codebase (DSP, Dsp, dsp etc...)
** TODO Add UI event firing from entrypoint
   Might not be the best way to do this, who knows.
** TODO Improve the frontend
*** TODO Get rid of the annyoing redundant clicks!!
*** TODO Settings accessible on the frontend
*** TODO Make a spec before randomly writing a lot of code
*** TODO Redo basic UI
   Added react, now to learn using it. Ish

*** TODO Add functionality for making a recording
**** TODO UI elements
**** TODO Backend support

*** TODO Functionality for stim protocols?
**** TODO UI elements
**** TODO MEAME support?
**** TODO DSP support
    See refactoring representation element

** TODO Polish file playback
** TODO MCS file fixerino reduxerino
** TODO Less unescessary restarts for both SHODAN and MEAME
*** DONE MEAME
*** TODO SHODAN
**** DONE [[*Chunk all data from TCP for easier restarts etc][Chunk Incoming]]
**** DONE [[*Redo entrypoint][Redo entrypoint]] 
**** TODO UI support
*** TODO Reset protocol(?)
    Might not be necessary unless we somehow lose track of an input stream
    In this scenario we can't demodulate the TCP datastream
    Have actually managed to trigger this error, so it might be an issue

** TODO Stimulus
*** TODO Rewrite stimulus.
**** DONE Write
    See MEAMEutilz
**** TODO Verify
** TODO Add tests
   Maybe read the chapter on prop testing in the red book?
*** DONE Get hello world test to run
    sort of, the frontend kinda stopped working... hurr!
*** TODO Make simple sine wave playback server/harness
*** TODO Make database playback mock server/harness
   
** TODO Spec out and properly implement DB
*** TODO add more todo items
** TODO Refactor Feedback pipe
   not critical
*** TODO figure out how to dequeueAvailable without losing unconsumed
*** TODO The filter should not be responsible for termination
**** TODO Can we change evaluator to a Pipe[F, O, Option[Double]]
     Might deadlock or whatever
    
** TODO Better handling of parameters
*** TODO Define requirements
    'better' is not a requirement, although in its current state it's not
    100% wrong either. Possibly params could be a signal or some other IO
    mutable construct, including an isReady IO[Bool].
    Sort of react-ish way of handling it

** TODO Add TCP listening for other users, possibly on specific channels
   With HTTP
** TODO Refactor registry representation
*** DONE Refine register representation.
*** DONE Check correctness of STG.scala
*** TODO Make specialized rendering per field basis
   For instance electrode enable should use ✘ and ✓ instead of dumping everything
   Similarily, this allows for more sensible per group rendering.
   Currently it's worth asking if this is actually needed, can we simply get by
   with a specialized function? (yes)
*** TODO Create specialized stimulus upload
   Let this be handled on the DSP for now...
*** TODO Refactor HttpClient stuff, get the forest under control.
   
** TODO Redo build file
   Look at build.sbt.next
   When testing out the new build file make sure scala js
   actually updates.
   
   
* Finished
** DONE Create minimal repro of scope error 
   Something about topics is causing shit to go ultra-south...
** DONE Verify entrypoint2
*** DONE Broadcasting
*** DONE MEAME data
*** DONE File playback
    Works, but crashes on empty string in the end
*** DONE Agent
** DONE Implement and test finalizing of db recording.
** DONE Verify and finish file playback.
*** DONE Add basic user interface support
*** DONE Figure out how to start and stop recordings
    Start should be params -> IO[IO[Unit]] perhaps?
    Outer IO is the start, the inner IO is the finalization which
    writes metadata to the db etc?
    
    This ended up getting a lot more involved actually!
    
*** DONE Verify that recording triangle waves from MEAME2 works
**** DONE Stream to database
     Had an issue where using a queue would cause displaying and
     saving data caused the data to get split, rather than duplicated.
     
     Now uses topic, which should fix the problem
     
**** DONE Stream from database
*** DONE Get throttling to work properly
*** DONE Verify correctness
    Some verification dawg...
   
** DONE Redo entrypoint
*** DONE Implement IO actions as described in [[file:backend/src/main/scala/cyborg/entrypoint2.scala::case%20class%20ProgramState(][program state]] 
    When shut down, a process must: 
    + notify the UI
    + set its boolean to false
    Pausing a recording has been considered but does not make 
    sense since this would lead to a seemingly fine recording 
    with a temporal jump.
**** DONE stop and start data acquisition from MEAME
**** DONE stop (finalize) and start recording 
**** DONE stop and start data playback from DB
     We will not be doing pausing at the time being
**** DONE stop and start agent
***** DONE make the GA runner stoppable and startable 
*** DONE Resetting MEAME
    Will not implement
    
** DONE Write more documentation
** DONE Stim req system
*** DONE Implement
*** DONE Test
**** DONE Implement logging rig
**** DONE Debug with logging rig
** DONE Implement stim on MEAME
** DONE Fix perf issue with sending data to frontend. It keeps buffering way past shutting down MEAME
  Turns out it was queue segment size being 1
*** DONE Try to create a send only program
*** DONE Figure out the deal with queue sizes
   dequeueAvailable or dequeueBatch achieves what we're after

** DONE Chunk all data from TCP for easier restarts etc
   As it is, the datastream from MEAME and the DB does not identify which segment is running.
   By adding tags we can make it easier to restart etc.
   Should topics get the same treatment?
** DONE Fix the GA for the last time
*** DONE Create generic version
*** DONE Test with simple example
*** DONE reimplement GA in terms of generic version
**** DONE Implement
**** DONE Make it work
  
** DONE Add sine wave generator on MEAME for debugging
  Ended up being sawtooth, no difference really


* Dropped and/or Not needed

  
* how 2 fs2 fra gitter (ikke slett plz)
Yeah, I do that in too many places
but soon I've got a working version out, then I'm gonna refactor and write good tests and all that jazz while the stable version automagically outputs research data
and everyone will be happy

Fabio Labella @SystemFw 15:51
then you'd need to write the usual recursive function as you do with Pulls in general
and then recursive(input).stream to get a Pipe

PeterAaser @PeterAaser 15:52
btw, is there a good place to get an idea of how fs2 works on the inside?

Fabio Labella @SystemFw 15:52
yes
the code :stuck_out_tongue:

PeterAaser @PeterAaser 15:52
Say I want to learn enough about to fs2 to actually contribute

Fabio Labella @SystemFw 15:52
sorry

PeterAaser @PeterAaser 15:52
How would you start

Fabio Labella @SystemFw 15:52
so there's a few layers, so to speak

PeterAaser @PeterAaser 15:52
I've actually read much of the code, but I tend to not stray into the core parts where scary things lie

Fabio Labella @SystemFw 15:53
so what I do

PeterAaser @PeterAaser 15:53
like don't ask me what a FreeC is (Free and coyoneda?)

Fabio Labella @SystemFw 15:53
no, that's just a Free monad with an extra constructor to take care of exception handling
cats Free already has coyoneda embedded in it
so I have a few random suggestions
first of all, master the Stream api (apart from where concurrency is involved)
assuming that it works by magic
but like, try and figure out what each method does, how to combine them, useful patterns and the like

PeterAaser @PeterAaser 15:55
I'm pretty good at the stream API. My activity in this channel might give a false impression, but that's because I usually only ask when I need to do something stupid :stuck_out_tongue:

Fabio Labella @SystemFw 15:55
lol I was speaking in general, not your specific knowledge :stuck_out_tongue:

PeterAaser @PeterAaser 15:56
but it's definitely a good place to keep improving

Fabio Labella @SystemFw 15:56
then do the same, but learning about the implementations
which are kinda divided in different categories
i.e. things that are written in terms of other streams combinators <- these are the best
concurrency/cats-effect <- I'll tell you about this in a second
things that are implemented using Pull <- this are the second best

PeterAaser @PeterAaser 15:57
How about stuff like scopes which aren't really visible to the end user?

Fabio Labella @SystemFw 15:57
things that are primitives <- last

PeterAaser @PeterAaser 15:57
unless something that shouldn't explode explodes

Fabio Labella @SystemFw 15:57
well, you just need to figure out the core interpreter for that
so Algebra
it's tricky, not gonna lie

PeterAaser @PeterAaser 15:58
haha I remember some of the signatures from 0.9

Fabio Labella @SystemFw 15:58
a good exercise is to dive into the async package, however
it's kinda standalone

PeterAaser @PeterAaser 15:58
The algebraF thing
that's a good tip

Fabio Labella @SystemFw 15:58
what I did
is spending a weekend going from the Java memory model (which you need to understand the lock-free queue used in actor)
then from actor to the implementation of Ref
than from the semantics of Ref to the concurrent data structures
and then from there to the concurrent combinators join, start concurrently and so on

PeterAaser @PeterAaser 16:00
That's for the async part, right?

Fabio Labella @SystemFw 16:00
yes
there's kinda two styles of concurrency is fs2 (this is my own informal split, so don't take it for granted)

PeterAaser @PeterAaser 16:00
Right, that sounds like a good way to go about it

Fabio Labella @SystemFw 16:00
stuff in async, which I've just mentioned
and stuff like merge, which ultimately relies on AsyncPull
but the async package itself is challenging enough as a start, imho
one extra tip
you don't have to go all the way down
for example, there's no need to understand how Actor works

PeterAaser @PeterAaser 16:01
Yeah, that's a good point

Fabio Labella @SystemFw 16:01
its semantics are very clear, so you can assume them as primitives
because understanding actor can be very tricky
I'm keen on low level concurrency so I did that
but it's not necessary
unless you fancy reading about lock-free algorithms in C

PeterAaser @PeterAaser 16:02
Haha, I'm running the parallel computations coursework at my university
I try very hard to avoid semaphores and similar unless I absolutely have to

Fabio Labella @SystemFw 16:03
You should also bear in mind that I'm a maintainer, and I don't know everything about the library yet

PeterAaser @PeterAaser 16:03
It's just impossible to get them right consistantly

Fabio Labella @SystemFw 16:03
so you could definitely contribute something while you learn
well, the fs2 semaphores are quite nice :P
but yeah, have you ever used haskell STM?

PeterAaser @PeterAaser 16:04
Thanks a lot, I hope I get some free time soon so I can finally go back to dagobah and finish my jedi training
No, learning haskell is on my to-do list
can't be that hard to learn haskell when I write functional scala

Fabio Labella @SystemFw 16:04
:+1:
sweetest concurrency model I've used
actually, you're mostly going to find that a lot of things are easier/less convoluted
although I really like scala as well

PeterAaser @PeterAaser 16:05
I really prefer scalas syntax, it's much easier for me to parse
although I dislike curly braces
and the type inferenc
Like how can Nil not be inferred
aornshdi

Fabio Labella @SystemFw 16:06
ime, syntax really does depend on habit
I used to hate scala syntax and its noise
now I don't mind it at all

PeterAaser @PeterAaser 16:06
(0 /: List[A[Lot[Of[Stuff]]]]())(_+_)

Fabio Labella @SystemFw 16:06
lol

PeterAaser @PeterAaser 16:06
instead of (0 /: Nil)(_+_)
but apart from that I find scalas type declarations to be very informative and I don't mind them at all

Fabio Labella @SystemFw 16:07
foldl' 0 (+)
the kind syntax is atrocious

PeterAaser @PeterAaser 16:08
I quite like /:
oh yes
but bearable with macros luckily
that's why I bet on scala, because shit like that ends up being fixed
and not just with boilerplate tools
lol, friend sent me this
http://i.4cdn.org/sci/1507818316576.png

proof via interpretive dance

Fabio Labella @SystemFw 16:09
amazing

PeterAaser @PeterAaser 16:09
we should totally find out what it is and find a way to incorporate it into the fs2 docs

* React
  < is for tags and tag attributes (<.div and <div looks similar)
  ^ is for attributes since it's concise

  underscore seemingly indicates we don't want to care about renderscope

  render_P: ((String) => VDomElement)                                  => Step4
  renderP:  ((RenderScope[String, Unit, Unit], String) => VDomElement) => Step4

  the renderScope is typically passed as $ (which is a legal identifier in scala, who knew)

  props: basically function argument for a UI component
  state: stuff that changes which a component may or may not react to (?)

* React Code scalajs vs js
#+begin_src js
  class ProductCategoryRow extends React.Component {
    render() {
      return (
        <tr>
          <td style={{fontWeight: 'bold'}}>{this.props.category}</td>
        </tr>
      );
    }
  }
#+end_src

  translates to

#+begin_src scala
  val ProductCategoryRow_ = ScalaComponent.builder[String]("ProductCategoryRow")
    .render_P(category => <.tr(<.th(^.colSpan := 2, category)))
    .build
#+end_src

  The takeaway is that the render_P expects a string from a prop which the js version
  does more explicitly
  Also the scala version is very terse with the < and ^ notation, maybe we can afford
  more linebreaks, keeping in mind that the js version also has to close...

** More
#+begin_src js
class Timer extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      secondsElapsed: 0
    };
    this.tick = this.tick.bind(this);
  }

  tick() {
    this.setState({secondsElapsed: this.state.secondsElapsed + 1});
  }

  componentDidMount() {
    this.interval = setInterval(this.tick, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.interval);
  }

  render() {
    return React.createElement("div", null, "Seconds Elapsed: ", this.state.secondsElapsed);
  }
}

ReactDOM.render(React.createElement(Timer), mountNode);
#+end_src

* Circe
  Figure out how I can work with Map for working with registers info without having to resort to
  the clumsy stuff I'm using now.

* On registers and DSPs
  Problem: A device can be controlled by setting bits, however this is a very
  primitive encoding, offering no semantic description.
  
  A register may contain several fields, and some registers may even have
  different semantics for some bits based on other bits.
  
  I want a system that feels more ergonomic to program, but also allows us
  to catch impossible configurations at compile time, which means we prefer
  registers to not be stringly typed. We may even go as far as having codecs
  specific for some memory regions which allows us to decode a register that
  can have multiple meanings. This might make compile time detection of errors
  harder, but we can possibly use decoders only and simply dump the register 
  if it's invalid.
  
  There are several possible identifiers for a register:
  + name
    A register should have a semantic name. Should address -> name be surjective?
    injective?

  + address
    Should all addresses be covered?

  + group membership?

  What we're really trying to describe is the relations address, field, name
  and package it somewhat reasonably
  
  We want to be able to query fields, set fields, we shouldn't have to care
  about addresses at all other than when visualizing.
  Do we want custom visualizers?
  
** Syntax?
   Problem: We want a map of possible 
   
* Database notes
** To open db in terminal:
   peter$~/:    sudo su postgres
   postgres$~/: psql -d world -U postgres

   select name from country;
   \q
** To redo a database
   peter$~/:    sudo su postgres
   postgres$~/: psql -c 'drop database $db;' -U postgres
   postgres$~/: psql -c 'create database $db;' -U postgres
   postgres$~/: psql -c '\i $db.sql' -d $db -U postgres
   
** Some commands
   \dt to show tables

** Doobie pitfalls
   For the doobie sql string interpolator $ is not simply textual replacement!
   This means that 
   #+begin_src scala
     val aa = "aa"
     val zip = "ZIP"
     sql"""
       INSERT INTO dataRecording (experimentId, resourcePath, resourceType)
       VALUES (123, $aa, $zip)
     """.update.check.unsafeRunSync()
    #+end_src

   is not equal to
   
   #+begin_src scala
    sql"""
      INSERT INTO dataRecording (experimentId, resourcePath, resourceType)
      VALUES (123, aa, zip)
    """.update.check.unsafeRunSync()
   #+end_src

   However this does not hold for numbers!
   
   

* About neurons
** Filtering
   None of these assumptions have any sort of neurological basis, they're just assumed
   in order to get a working prototype.

   I assume maximum amount of spikes we're interested in recording is 50 per second


* Issues with output from MEAME
  It seems the data corruption issues only happen with low samplerates.
  With a samplerate of 1khz I get garbage, but at 10khz the channels are correctly rendered, 
  albeit with the weird overlap artefact.
  Gunnar suggests DSP using only one of its two memory bands. Not too far fetched
  
* Dev diary
** GA terminates after one evaluation
   Turns out the filter terminated after TicksPerEval,
   however we need 5*ticksPerEval for 5 challenges!
   This is a hint that the current method isn't very
   ergonomical, it should not be the responsibility of
   the filter to know when it's done.

** Figuring out how to represent state in SHODAN
   Having a commandPipe seems like a decent approach, but 
   I don't like how it currently does not really alter its 
   state inbetween updates.
   
*** Problem 1: The frontend does not get updated. 
    The commandpipe and the frontend does not share a model.
    I want a react-ish model where state changes in the
    commandpipe and the actions it is running will automatically 
    be visible to the frontend.
    
*** Problem 2: Commandpipe is essentially stateless.
    The commandpipe is not in a good state at the moment.
    Warts such as uns*feRun in StartMEAME and generally finding 
    it difficult to alter the go function inbetween invocations.
    
*** Possible solutions:
**** Signal
     commandPipe could simply broadcast to a signal, and each listener 
     case matches. Possibly multiple listeners can listen to the same 
     token such that when running from DB and a MEAME token is submitted 
     then we stop running from DB, and recording finalizes when data 
     source is switched.
     
**** Topic
     Topics are many in many out, more geared towards streaming mass data 
     than Signal (which lacks a Sink method). Topic and Signal can both 
     be implemented in terms of each other for my case, ignoring more 
     tricky effects wrt asynchronity.

**** More sophisticated pull
     By keeping the current model the problems above must be resolved.
     A signal should still be implemented in order to handle failure and/or 
     interruption of a task, for instance MCS hardware exploding.
     
*** Going with signals?
    The various methods in assemblers must now return an interrupt action which 
    can then be stored in the ProgramState case class.
   
** A better toplevel interface
*** Description
    In order to make SHODAN more flexible it is necessary to add support 
    for handling user actions that change the state of a running program. 
    In order to do this I have currently settled on a model where a signal 
    holding a program state is used, which is both read and set by a pipe 
    for user commands. 
    The signal has many listeners, and the listeners may alter the signal  
    state themselves, which leaves open the question about how to handle 
    cycles in the listener graph etc in a safe manner.
    While this is of course ultimately undecidable it would be nice to have 
    at least some measure of static analysis.
    Another problem with the current approach is the lack of atomicity, i.e it is 
    possible to set meameRunning to false without actually running the 
    corresponding IO[Unit] stopData.
   
    What is it that I actually want?
    Ideally I would like to have a language where I could specify constraints such as
    "If the data acquisition stops, so must any DB recording."
    "If data acquisition is restarted then recordings should stop"
    "If data acquisition start is issued when data acquisition is running then a restart is issued"
    etc...
   
**** A start stop class
     When starting a data broadcast I also want to get an action to stop the broadcast.
     One way to do this is to change the signature to IO[(IO[Unit],IO[Unit])] but in 
     this case it is not possible to tell which IO action runs the broadcast and which 
     stops it. To rectify this I simply made the InterruptableAction case class in utilz.
    
**** Doing unrelated things based on input
     When a RunFromDB token is received we would like to shut down MEAME in addition to 
     setting up the DB datastream. 
     In the initial solution I matched for StopMEAME | RunFromDB to run the MEAME shutdown, 
     but this has the effect that the 
    
**** The case for full match
     It would be useful if we could do a full version of match. In match we want a single value 
     (which is why non-exhaustive matching is a compiler error with sealed trait, or runtime 
     error if not)
    
     For some sealed ADT A we'd like fullMatch A to return NEL[A] or give a compiler error.
     Possibly we could allow a fullMatch A to return List[A] instead where the list may be 
     empty.
    
     For now it seems using partial functions is the best way to do this, simply run input 
     through all the PFs to get a List[Option[Action]] which I fold and collapse to a single 
     action!
    
     PartialFunction may not be what we're after since we run into awkward behavior when using 
     predicates. 
     With match we can mix a type match with a predicate (i.e case A if someCondition => ...) 
     however this is not so easy with the proposed partialFunction approach...
    
**** Ideal and real phase decoupling
     What if user commands simply changes the desired "ideal" state of the program, and it's up
     to the different components listening to the program state signal to change their state to 
     reflect this? This way user commands could be idempotent, meaning in order to restart 
     MEAME you would have to first turn it off, then back on. Is this really desirable?
    
**** A case match recursively calling itself until it is resolved?
     A two-tiered system where the cmd pipe can issue new commands to itself. This fixes the case
     where a restart is issued. Now the cmd pipe can for instance issue a shutdown then a start 
     command to itself in the case that it receives a start command when already started (restart).
    
     Won't work without semaphores and similar to synchronize between the signal handlers and the 
     command pipeline. Atm I'm too tired of this mess, so I'm just going to have to be brutally practical tm...

*** Resolution
    The chosen architecture is a commandPipe responsible for reading commands and changing the 
    ideal program state based on this. 
    Several listeners discrete stream changes to program state and respond accordingly, modifying 
    the program state as they go. Definitely not a perfect approach, does not make nasty race 
    conditions hard to express, but needs to be settled.
    
*** Thoughts
    Some of the issues might stem from stuffing all inputs into a single pipe.
    Maybe the HTTP server could handle most of it, if not all?
    
** A bug in fs2
   TODO write about it
* FS2 mysteries
** Termination of unit streams
   for some F[Unit] we may or may not get a reasonable termination.
   Consider the following: 
   val a = IO { println("hello") }
   val b = IO { read data from a socket and write to a different socket }
   Obviously a terminates, b does not, but this isn't really apparent in the signatures.
   This has a tendency to trip me up when using evalMap!
   
   val s = Stream(0,1,2,3).repeat.evalMap( z => if(z mod 2) a else b)

   Here I'm thinking that this won't clog, but of course it will because on token 1 we start an 
   IO action that will not terminate.
   
   Typically this ends with me using something silly like
   
   (Stream(0,1,2,3).repeat.map( z => if(z mod 2) a else b)).through(_.map(Stream.eval(_))).joinUnbounded
   
   This is silly, it would be better if tasks would themselves indicate that they were async or sync,
   and this certainly exists in fs2 or the cats IO ecosystem!
   
   I suppose this is where you need Async, Schedulers, Strategies and more, since you want to have 
   a strategy for performing async tasks instead of defining the execution strategy at the task creation!
   
   
   
   
* Clogged stream checklist
  + NYI exceptions might end up being swallowed
  + Check if all streams are running, not just the head of a stream of streams etc.
  + Check for Stream[F,Nothing] >> Stream[F,A]
    This is wrong, should be Stream[F,Nothing] ++ Stream[F,A]
** Previous cases
     
*** The mystery of the silent topics
   I suspect this issue has been a problem for a long time, but I finally found it when
   working on porting the GA to the new generalized framework.
   This gave me a very large surface of errors, I'm not sure it was a good idea, or if I
   would have been better off using the old GA stuff, which at least worked.
   After unsuccessfully looking at the GA and generalized pipe code I decided to test if
   data was even getting through which I did by printing the head of the list of streams from
   topic in Assemblers. This only worked because I happened to choose the first topic, which
   it turns out had all the data. I then tried to rewrite roundrobin yet again (poor round
   robin was likely framed many times because of this silly bug). When I couldn't get that 
   to work, I tried to simply interleave the two first streams, which also clogged! I then
   attempted to run output only from the second stream, which gave no output! This made me 
   realize that in all likelyhood the broadcaster had a bug, which it indirectly did. The
   broadcaster simply multiplexes tagged segments based on their channel tag, tags which was
   added in the tag pipe. The tag pipe was the source of the bug in the end, as it didn't 
   actually increment the tag inbetween segments! OOPS!!!
   Fix: 
   
   >>>>>>
   Pull.output1(TaggedSegment(n, seg.toVector)) >> go(n%60, tl)
   <<<<<<
   Pull.output1(TaggedSegment(n, seg.toVector)) >> go((n + 1) % 60, tl)
          
*** Return of the unimplemented method
    Implemented a new pipe for producing stimulus signal periods. The function from Hz to 
    period was not implemented but the exception was swallowed.
    This should be tested properly, but until then using ??? is very dangerous since NYI 
    errors might be swallowed.

* On testing
  Scala has 3 major testing frameworks.
  + ScalaCheck
    Focuses on property-based testing 
  + specs2
    Concentrates on behavior-drive development. 
  + ScalaTest 
    a flexible testing platform.
    "ScalaTest enables teams to use the style of testing that fits them best, and
    supports property-based testing via integration with ScalaCheck."
  
  These frameworks are compatible with each other, typically
  ScalaTest and ScalaCheck are used in conjunction.

* Signatures I keep having to look up
** evalMap
   #+begin_src scala
    /**
      * Alias for `flatMap(o => Stream.eval(f(o)))`.
      *
      * @example {{{
      * scala> import cats.effect.IO
      * scala> Stream(1,2,3,4).evalMap(i => IO(println(i))).compile.drain.unsafeRunSync
      * res0: Unit = ()
      * }}}
      */
    def evalMap[O2](f: O => F[O2]): Stream[F, O2] =
      self.flatMap(o => Stream.eval(f(o)))

   #+end_src
   
** Bracket
   #+begin_src scala
    /**
      * Creates a stream that depends on a resource allocated by an effect, ensuring the resource is
      * released regardless of how the stream is used.
      *
      * @param r resource to acquire at start of stream
      * @param use function which uses the acquired resource to generate a stream of effectful outputs
      * @param release function which returns an effect that releases the resource
      *
      * A typical use case for bracket is working with files or network sockets. The resource effect
      * opens a file and returns a reference to it. The `use` function reads bytes and transforms them
      * in to some stream of elements (e.g., bytes, strings, lines, etc.). The `release` action closes
      * the file.
      */
      def bracket[F[_], R, O](r: F[R])(use: R => Stream[F, O], release: R => F[Unit]): Stream[F, O] = ...
   #+end_src
