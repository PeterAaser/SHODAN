* TODO IO
** DONE Investigate codebase IO and sketch out spec
   120 min (35 min)
   
   Possibly add IO-Control for prettifying the whole http interface?
   Currently I have large blocks of code in entrypoint doing rather arbitrary stuff.
   
   Ideally IO-Control should contain composable imperative blocks that can be strung
   together using a free monad.
   
   All IO blocks should then either observe async, or consume a stream.
   Possibly the IO block for starting MEAME should return two tokens (one-time use?)
   that can be used to start a stream from either full channel or selective channel.

   Seemingly we want to always go full channel, even for ANN input. It would be a good
   idea to run some tests to see if the slowdown experienced was because of sync/async.
   
   A set of utils to attach and detach observers etc could be fairly useful.
   In order to refactor IO a test-suite is getting pretty necessary, rather than
   always testing manually.
   Possibly a benchmarking tool should be used as well?

   Decide if we want to go full DSL or not on experiment assembly
   
   Entrypoint should still be the staging area for the IO pipes, needing only to import
   IO-Control

** TODO String all that shit together in a free monad
   ???
   read the red book once more

* TODO Add a goddamn test-suite
** TODO Spec out what I actually want to test
   30 min
** TODO Make some reasonable cases
   30 min
** TODO explore mocked streaming
** TODO explore streaming from DB 
** TODO explore benchmarking
   
* TODO general housecleaning
** TODO GA
** TODO subdividing
** TODO "User area" removed from core logic
** TODO Consider making SHODAN more library-like
** TODO remove all instances of the word "meme"
*** nice meme
** TODO Refactor pipe assemblies again
* TODO Investigate signal processing methods
** Implementation
*** Native libraries
*** Matlab -> JVM
*** Offload to FPGA
**** Chisel!
*** Offload to DSP

** Theoretical
*** Hør med Geir og Martinius

* TODO Better DI
** TODO Figure out best practice for DI
*** TODO Try out Free monad, ReaderWriter, or tagless final encoding (ps I have no fucking idea..)
** DONE SHODAN should be able to select experiment params from either file of conf.
   CLOSED: [2017-05-18 to. 16:54]
   Shitty version is in fact done

* TODO Implement throttling streams
* TODO Visualize spike detection
* TODO Improve visualizers
* TODO Rething user interaction
* TODO Reimplement stimuli
  reimplement? really?
* TODO Better UX
** Must be able to start/restart without refreshing webpage
** MEAME2 must be able to handle all sorts of bullshit from the frontend
** Robustness must be enforced, clicking two buttons to visualize is unacceptable

* TODO Add testing

* Neste gang
  Fikset tull med topics. Se på mainrunner, få httpServer back up
  Tror det funker med st olavs data nå
  
* Database specification
** ER
   For each experiment
*** Metadata
   Experiment parameters
   Date (start, finish)
   Culture name
   Textual description

*** Experiment data
   Raw data chunks?

   On experiment start: if data recording: create an experimentInfo field and a set of channelRecordings.
   Each channelRecording should get its own sink for storing data.
** Use cases
*** Query for all recordings in some timespan
*** Query for all recordings with length over 4 minutes
*** Reading the experiment the runner decides to retry from some timestamp with a different filter
*** A program reads both raw data and a processed stream (spike data)
*** A program processes spike detection for all recordings in some range of time

* Database notes
** To open db in terminal:
   peter$~/:    sudo su postgres 
   postgres$~/: psql -d world -U postgres
  
   select name from country;
   \q
** To redo a database
   peter$~/:    sudo su postgres 
   postgres$~/: psql -c 'drop database $db;' -U postgres
   postgres$~/: psql -c 'create database $db;' -U postgres
   postgres$~/: psql -c '\i $db.sql' -d $db -U postgres
   
   
* About neurons
** Filtering
   None of these assumptions have any sort of neurological basis, they're just assumed
   in order to get a working prototype.

   I assume maximum amount of spikes we're interested in recording is 50 per second

* QUEUE
** Read the red book about free monads
** Read the red book about scalatest

* TODO Unified source
  Should gather up an entire segment. 
  Inbetween each segment new queues may be added to the send queue.
  
  If the topic solution is used then each segment must have an identifier
  in order to assure synchronization between topics. 
  if I sub to topic 4, 5 and 9 with segments 445, 445 and 446 then I must
  discard a segment from topic 4 and 5.

  This doesn't matter for visualizing, but it's important for ANNs etc.
  
** Use case:
*** Source arbitrates a connection, either to DB or to MEAME
*** User starts visualizing 
    From the source PoV this is just a bunch of (queue, channel) tuples
*** User stops visualizing
    The source must remove the now invalid queues
*** Visualization is restarted
    Same as first
*** ???
    
